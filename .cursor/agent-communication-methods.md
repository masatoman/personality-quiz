# エージェント間コミュニケーション実装方法

## 1. ファイルベースのコミュニケーション

### 共有ディレクトリ構造
```
.cursor/
  ├── communications/              # コミュニケーション用ディレクトリ
  │   ├── inbox/                  # 各エージェントの受信ボックス
  │   │   ├── design/            # デザインエージェント宛
  │   │   ├── frontend/          # フロントエンドエージェント宛
  │   │   └── backend/           # バックエンドエージェント宛
  │   │
  │   ├── status/                # 状態共有ディレクトリ
  │   │   ├── design-status.json    # デザインエージェントの状態
  │   │   ├── frontend-status.json  # フロントエンドエージェントの状態
  │   │   └── backend-status.json   # バックエンドエージェントの状態
  │   │
  │   └── shared/                # 共有リソースディレクトリ
  │       ├── api-specs/         # API仕様書
  │       ├── design-system/     # デザインシステム
  │       └── test-results/      # テスト結果
  │
  └── logs/                      # 作業ログディレクトリ
      ├── design/                # デザインエージェントのログ
      ├── frontend/              # フロントエンドエージェントのログ
      └── backend/               # バックエンドエージェントのログ
```

### メッセージファイル形式
```json
{
  "id": "msg-20240319-001",
  "timestamp": "2024-03-19T10:00:00Z",
  "from": "design",
  "to": "frontend",
  "type": "notification",
  "priority": "high",
  "subject": "デザインシステムの更新",
  "content": {
    "description": "ボタンコンポーネントの仕様を更新",
    "changes": ["サイズバリエーションの追加", "アクセシビリティ対応"],
    "resources": ["/shared/design-system/components/button.md"]
  },
  "requires_response": true,
  "due_date": "2024-03-19T15:00:00Z"
}
```

## 2. 状態監視とポーリング

### エージェントの状態ファイル（status.json）
```json
{
  "agent": "frontend",
  "current_task": "task-123",
  "status": "implementing",
  "progress": 45,
  "last_updated": "2024-03-19T10:00:00Z",
  "blockers": [],
  "waiting_for": ["design:task-120"],
  "next_tasks": ["task-124", "task-125"]
}
```

### ポーリング間隔
- 状態確認: 30秒ごと
- メッセージ確認: 1分ごと
- 共有リソース更新確認: 5分ごと

## 3. コミュニケーションフロー

### メッセージ送信
1. 送信エージェントが`inbox/{target_agent}/`に新規メッセージファイルを作成
2. ファイル名形式: `{timestamp}-{from}-{message_id}.json`
3. 受信エージェントのステータスファイルに未読メッセージとして記録

### メッセージ受信
1. 定期的に自身の`inbox/`ディレクトリをポーリング
2. 新規メッセージを検出したら内容を読み込み
3. メッセージの優先度に応じて処理を実行
4. 処理完了後、メッセージを`processed/`ディレクトリに移動

### 緊急通知
1. 緊急メッセージは`priority: "urgent"`を設定
2. ポーリング間隔を5秒に短縮
3. 受信エージェントの作業を中断して対応

## 4. リソース共有方法

### デザインシステムの更新
1. デザインエージェントが`shared/design-system/`を更新
2. 更新内容を`design-status.json`に記録
3. フロントエンドエージェントが変更を検知して反映

### API仕様の更新
1. バックエンドエージェントが`shared/api-specs/`を更新
2. 更新内容を`backend-status.json`に記録
3. フロントエンドエージェントが変更を検知して反映

### テスト結果の共有
1. 各エージェントが`shared/test-results/`に結果を保存
2. 結果ファイル名: `{agent}-{test-type}-{timestamp}.json`
3. 他エージェントが定期的に結果を確認

## 5. エラー処理

### ファイルロック
1. 共有リソース更新時にロックファイルを作成
2. 更新完了後にロックを解除
3. タイムアウト時は強制解除（5分）

### 競合解決
1. 同時更新を検知した場合はタイムスタンプを比較
2. 新しい方を優先
3. 競合内容を両エージェントに通知

### エラーリカバリー
1. 破損ファイルの検出時はバックアップから復旧
2. 通信エラー時は再試行（最大3回）
3. 重大なエラーは全エージェントに通知

## 6. モニタリング

### ログ記録
1. 各エージェントの作業ログを`logs/{agent}/`に保存
2. ログローテーション: 日次
3. ログレベル: INFO, WARN, ERROR

### 状態監視
1. エージェントの生存確認
2. リソース使用状況の監視
3. エラー頻度の監視

### メトリクス収集
1. メッセージ処理時間
2. 応答時間
3. エラー率 